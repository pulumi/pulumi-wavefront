// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.wavefront.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetDashboardsDashboardSectionRowChartChartSetting {
    /**
     * @return This setting is deprecated.
     * 
     */
    private Boolean autoColumnTags;
    /**
     * @return This setting is deprecated.
     * 
     */
    private String columnTags;
    /**
     * @return For the tabular view, a list of point tags to display when using the `custom` tag display mode.
     * 
     */
    private List<String> customTags;
    /**
     * @return Threshold (in seconds) for time delta between consecutive points in a series above which a dotted line will replace a solid in line plots. Default is 60.
     * 
     */
    private Integer expectedDataSpacing;
    /**
     * @return (Optional) For a chart with a fixed legend, a list of statistics to display in the legend.
     * 
     */
    private List<String> fixedLegendDisplayStats;
    /**
     * @return (Optional) Whether to enable a fixed tabular legend adjacent to the chart.
     * 
     */
    private Boolean fixedLegendEnabled;
    /**
     * @return (Optional) Statistic to use for determining whether a series is displayed on the fixed legend. Valid options are `CURRENT`, `MEAN`, `MEDIAN`, `SUM`, `MIN`, `MAX`, and `COUNT`.
     * 
     */
    private String fixedLegendFilterField;
    /**
     * @return (Optional) Number of series to include in the fixed legend.
     * 
     */
    private Integer fixedLegendFilterLimit;
    /**
     * @return (Optional) Whether to display `TOP` or `BOTTOM` ranked series in a fixed legend. Valid options are `TOP`, and `BOTTOM`.
     * 
     */
    private String fixedLegendFilterSort;
    /**
     * @return (Optional) This setting is deprecated.
     * 
     */
    private Boolean fixedLegendHideLabel;
    /**
     * @return (Optional)  Where the fixed legend should be displayed with respect to the chart. Valid options are `RIGHT`, `TOP`, `LEFT`, `BOTTOM`.
     * 
     */
    private String fixedLegendPosition;
    /**
     * @return (Optional) If `true`, the legend uses non-summarized stats instead of summarized.
     * 
     */
    private Boolean fixedLegendUseRawStats;
    /**
     * @return For the tabular view, whether to group multi metrics into a single row by a common source. If set to `false`, each source is displayed in its own row. If set to `true`, multiple metrics for the same host are displayed as different columns in the same row.
     * 
     */
    private Boolean groupBySource;
    /**
     * @return (Optional) Whether to disable the display of the floating legend (but reenable it when the ctrl-key is pressed).
     * 
     */
    private Boolean invertDynamicLegendHoverControl;
    /**
     * @return Plot interpolation type.  `linear` is default. Valid options are `linear`, `step-before`, `step-after`, `basis`, `cardinal`, and `monotone`.
     * 
     */
    private String lineType;
    /**
     * @return Max value of the Y-axis. Set to null or leave blank for auto.
     * 
     */
    private Double max;
    /**
     * @return Min value of the Y-axis. Set to null or leave blank for auto.
     * 
     */
    private Double min;
    /**
     * @return For the tabular view defines how many point tags to display.
     * 
     */
    private Integer numTags;
    /**
     * @return The markdown content for a Markdown display, in plain text.
     * 
     */
    private String plainMarkdownContent;
    /**
     * @return For the tabular view, whether to display sources. Default is `true`.
     * 
     */
    private Boolean showHosts;
    /**
     * @return For the tabular view, whether to display labels. Default is `true`.
     * 
     */
    private Boolean showLabels;
    /**
     * @return For the tabular view, whether to display raw values. Default is `false`.
     * 
     */
    private Boolean showRawValues;
    /**
     * @return For the tabular view, whether to display values in descending order. Default is `false`.
     * 
     */
    private Boolean sortValuesDescending;
    /**
     * @return For the single stat view, the decimal precision of the displayed number.
     * 
     */
    private Integer sparklineDecimalPrecision;
    /**
     * @return For the single stat view, the color of the displayed text (when not dynamically determined). Values should be in RGBA format.
     * 
     */
    private String sparklineDisplayColor;
    /**
     * @return For the single stat view, the font size of the displayed text, in percent.
     * 
     */
    private String sparklineDisplayFontSize;
    /**
     * @return For the single stat view, the horizontal position of the displayed text. Valid options are `MIDDLE`, `LEFT`, `RIGHT`.
     * 
     */
    private String sparklineDisplayHorizontalPosition;
    /**
     * @return For the single stat view, a string to append to the displayed text.
     * 
     */
    private String sparklineDisplayPostfix;
    /**
     * @return For the single stat view, a string to add before the displayed text.
     * 
     */
    private String sparklineDisplayPrefix;
    /**
     * @return For the single stat view, where to display the name of the query or the value of the query. Valid options are `VALUE` or `LABEL`.
     * 
     */
    private String sparklineDisplayValueType;
    /**
     * @return This setting is deprecated.
     * 
     */
    private String sparklineDisplayVerticalPosition;
    /**
     * @return For the single stat view, the color of the background fill. Values should be in RGBA format.
     * 
     */
    private String sparklineFillColor;
    /**
     * @return For the single stat view, the color of the line. Values should be in RGBA format.
     * 
     */
    private String sparklineLineColor;
    /**
     * @return For the single stat view, this determines whether the sparkline of the statistic is displayed in the chart. Valid options are `BACKGROUND`, `BOTTOM`, `NONE`.
     * 
     */
    private String sparklineSize;
    /**
     * @return For the single stat view, whether to apply dynamic color settings to the displayed `TEXT` or `BACKGROUND`. Valid options are `TEXT` or `BACKGROUND`.
     * 
     */
    private String sparklineValueColorMapApplyTo;
    /**
     * @return For the single stat view, a list of colors that differing query values map to. Must contain one more element than `sparkline_value_color_map_values_v2`. Values should be in RGBA format.
     * 
     */
    private List<String> sparklineValueColorMapColors;
    /**
     * @return This setting is deprecated.
     * 
     */
    private List<Integer> sparklineValueColorMapValues;
    /**
     * @return For the single stat view, a list of boundaries for mapping different query values to colors. Must contain one element less than `sparkline_value_color_map_colors`.
     * 
     */
    private List<Double> sparklineValueColorMapValuesV2s;
    /**
     * @return For the single stat view, a list of display text values that different query values map to. Must contain one more element than `sparkline_value_text_map_thresholds`.
     * 
     */
    private List<String> sparklineValueTextMapTexts;
    /**
     * @return For the single stat view, a list of threshold boundaries for mapping different query values to display text. Must contain one element less than `sparkline_value_text_map_text`.
     * 
     */
    private List<Double> sparklineValueTextMapThresholds;
    /**
     * @return Type of stacked chart (applicable only if chart type is `stacked`). `zero` (default) means stacked from y=0. `expand` means normalized from 0 to 1.  `wiggle` means minimize weighted changes. `silhouette` means to center the stream. Valid options are `zero`, `expand`, `wiggle`, `silhouette`, and `bars`.
     * 
     */
    private String stackType;
    /**
     * @return For the tabular view, which mode to use to determine which point tags to display. Valid options are `all`, `top`, or `custom`.
     * 
     */
    private String tagMode;
    /**
     * @return For x-y scatterplots, whether to color more recent points as darker than older points.
     * 
     */
    private Boolean timeBasedColoring;
    /**
     * @return Chart Type. `line` refers to the Line Plot, `scatter` to the Point Plot, `stacked-area` to the Stacked Area plot, `table` to the Tabular View, `scatterplot-xy` to Scatter Plot, `markdown-widget` to the Markdown display, and `sparkline` to the Single Stat view. Valid options are`line`, `scatterplot`, `stacked-area`, `stacked-column`, `table`, `scatterplot-xy`, `markdown-widget`, `sparkline`, `globe`, `nodemap`, `top-k`, `status-list`, and `histogram`.
     * 
     */
    private String type;
    /**
     * @return Width, in minutes, of the time window to use for `last` windowing.
     * 
     */
    private Integer windowSize;
    /**
     * @return For the tabular view, whether to use the full time window for the query or the last X minutes. Valid options are `full` or `last`.
     * 
     */
    private String windowing;
    /**
     * @return For x-y scatterplots, max value for the X-axis. Set to null for auto.
     * 
     */
    private Double xmax;
    /**
     * @return For x-y scatterplots, min value for the X-axis. Set to null for auto.
     * 
     */
    private Double xmin;
    private Boolean y0ScaleSiBy1024;
    /**
     * @return (Optional) Whether to automatically adjust magnitude labels and units for the left Y-axis to favor smaller magnitudes and larger units.
     * 
     */
    private Boolean y0UnitAutoscaling;
    private Double y1Max;
    private Double y1Min;
    private Boolean y1ScaleSiBy1024;
    /**
     * @return (Optional) Whether to automatically adjust magnitude labels and units for the right Y-axis to favor smaller magnitudes and larger units.
     * 
     */
    private Boolean y1UnitAutoscaling;
    /**
     * @return For plots with multiple Y-axes, units for right side Y-axis.
     * 
     */
    private String y1Units;
    /**
     * @return For x-y scatterplots, max value for the Y-axis. Set to null for auto.
     * 
     */
    private Double ymax;
    /**
     * @return For x-y scatterplots, min value for the Y-axis. Set to null for auto.
     * 
     */
    private Double ymin;

    private GetDashboardsDashboardSectionRowChartChartSetting() {}
    /**
     * @return This setting is deprecated.
     * 
     */
    public Boolean autoColumnTags() {
        return this.autoColumnTags;
    }
    /**
     * @return This setting is deprecated.
     * 
     */
    public String columnTags() {
        return this.columnTags;
    }
    /**
     * @return For the tabular view, a list of point tags to display when using the `custom` tag display mode.
     * 
     */
    public List<String> customTags() {
        return this.customTags;
    }
    /**
     * @return Threshold (in seconds) for time delta between consecutive points in a series above which a dotted line will replace a solid in line plots. Default is 60.
     * 
     */
    public Integer expectedDataSpacing() {
        return this.expectedDataSpacing;
    }
    /**
     * @return (Optional) For a chart with a fixed legend, a list of statistics to display in the legend.
     * 
     */
    public List<String> fixedLegendDisplayStats() {
        return this.fixedLegendDisplayStats;
    }
    /**
     * @return (Optional) Whether to enable a fixed tabular legend adjacent to the chart.
     * 
     */
    public Boolean fixedLegendEnabled() {
        return this.fixedLegendEnabled;
    }
    /**
     * @return (Optional) Statistic to use for determining whether a series is displayed on the fixed legend. Valid options are `CURRENT`, `MEAN`, `MEDIAN`, `SUM`, `MIN`, `MAX`, and `COUNT`.
     * 
     */
    public String fixedLegendFilterField() {
        return this.fixedLegendFilterField;
    }
    /**
     * @return (Optional) Number of series to include in the fixed legend.
     * 
     */
    public Integer fixedLegendFilterLimit() {
        return this.fixedLegendFilterLimit;
    }
    /**
     * @return (Optional) Whether to display `TOP` or `BOTTOM` ranked series in a fixed legend. Valid options are `TOP`, and `BOTTOM`.
     * 
     */
    public String fixedLegendFilterSort() {
        return this.fixedLegendFilterSort;
    }
    /**
     * @return (Optional) This setting is deprecated.
     * 
     */
    public Boolean fixedLegendHideLabel() {
        return this.fixedLegendHideLabel;
    }
    /**
     * @return (Optional)  Where the fixed legend should be displayed with respect to the chart. Valid options are `RIGHT`, `TOP`, `LEFT`, `BOTTOM`.
     * 
     */
    public String fixedLegendPosition() {
        return this.fixedLegendPosition;
    }
    /**
     * @return (Optional) If `true`, the legend uses non-summarized stats instead of summarized.
     * 
     */
    public Boolean fixedLegendUseRawStats() {
        return this.fixedLegendUseRawStats;
    }
    /**
     * @return For the tabular view, whether to group multi metrics into a single row by a common source. If set to `false`, each source is displayed in its own row. If set to `true`, multiple metrics for the same host are displayed as different columns in the same row.
     * 
     */
    public Boolean groupBySource() {
        return this.groupBySource;
    }
    /**
     * @return (Optional) Whether to disable the display of the floating legend (but reenable it when the ctrl-key is pressed).
     * 
     */
    public Boolean invertDynamicLegendHoverControl() {
        return this.invertDynamicLegendHoverControl;
    }
    /**
     * @return Plot interpolation type.  `linear` is default. Valid options are `linear`, `step-before`, `step-after`, `basis`, `cardinal`, and `monotone`.
     * 
     */
    public String lineType() {
        return this.lineType;
    }
    /**
     * @return Max value of the Y-axis. Set to null or leave blank for auto.
     * 
     */
    public Double max() {
        return this.max;
    }
    /**
     * @return Min value of the Y-axis. Set to null or leave blank for auto.
     * 
     */
    public Double min() {
        return this.min;
    }
    /**
     * @return For the tabular view defines how many point tags to display.
     * 
     */
    public Integer numTags() {
        return this.numTags;
    }
    /**
     * @return The markdown content for a Markdown display, in plain text.
     * 
     */
    public String plainMarkdownContent() {
        return this.plainMarkdownContent;
    }
    /**
     * @return For the tabular view, whether to display sources. Default is `true`.
     * 
     */
    public Boolean showHosts() {
        return this.showHosts;
    }
    /**
     * @return For the tabular view, whether to display labels. Default is `true`.
     * 
     */
    public Boolean showLabels() {
        return this.showLabels;
    }
    /**
     * @return For the tabular view, whether to display raw values. Default is `false`.
     * 
     */
    public Boolean showRawValues() {
        return this.showRawValues;
    }
    /**
     * @return For the tabular view, whether to display values in descending order. Default is `false`.
     * 
     */
    public Boolean sortValuesDescending() {
        return this.sortValuesDescending;
    }
    /**
     * @return For the single stat view, the decimal precision of the displayed number.
     * 
     */
    public Integer sparklineDecimalPrecision() {
        return this.sparklineDecimalPrecision;
    }
    /**
     * @return For the single stat view, the color of the displayed text (when not dynamically determined). Values should be in RGBA format.
     * 
     */
    public String sparklineDisplayColor() {
        return this.sparklineDisplayColor;
    }
    /**
     * @return For the single stat view, the font size of the displayed text, in percent.
     * 
     */
    public String sparklineDisplayFontSize() {
        return this.sparklineDisplayFontSize;
    }
    /**
     * @return For the single stat view, the horizontal position of the displayed text. Valid options are `MIDDLE`, `LEFT`, `RIGHT`.
     * 
     */
    public String sparklineDisplayHorizontalPosition() {
        return this.sparklineDisplayHorizontalPosition;
    }
    /**
     * @return For the single stat view, a string to append to the displayed text.
     * 
     */
    public String sparklineDisplayPostfix() {
        return this.sparklineDisplayPostfix;
    }
    /**
     * @return For the single stat view, a string to add before the displayed text.
     * 
     */
    public String sparklineDisplayPrefix() {
        return this.sparklineDisplayPrefix;
    }
    /**
     * @return For the single stat view, where to display the name of the query or the value of the query. Valid options are `VALUE` or `LABEL`.
     * 
     */
    public String sparklineDisplayValueType() {
        return this.sparklineDisplayValueType;
    }
    /**
     * @return This setting is deprecated.
     * 
     */
    public String sparklineDisplayVerticalPosition() {
        return this.sparklineDisplayVerticalPosition;
    }
    /**
     * @return For the single stat view, the color of the background fill. Values should be in RGBA format.
     * 
     */
    public String sparklineFillColor() {
        return this.sparklineFillColor;
    }
    /**
     * @return For the single stat view, the color of the line. Values should be in RGBA format.
     * 
     */
    public String sparklineLineColor() {
        return this.sparklineLineColor;
    }
    /**
     * @return For the single stat view, this determines whether the sparkline of the statistic is displayed in the chart. Valid options are `BACKGROUND`, `BOTTOM`, `NONE`.
     * 
     */
    public String sparklineSize() {
        return this.sparklineSize;
    }
    /**
     * @return For the single stat view, whether to apply dynamic color settings to the displayed `TEXT` or `BACKGROUND`. Valid options are `TEXT` or `BACKGROUND`.
     * 
     */
    public String sparklineValueColorMapApplyTo() {
        return this.sparklineValueColorMapApplyTo;
    }
    /**
     * @return For the single stat view, a list of colors that differing query values map to. Must contain one more element than `sparkline_value_color_map_values_v2`. Values should be in RGBA format.
     * 
     */
    public List<String> sparklineValueColorMapColors() {
        return this.sparklineValueColorMapColors;
    }
    /**
     * @return This setting is deprecated.
     * 
     */
    public List<Integer> sparklineValueColorMapValues() {
        return this.sparklineValueColorMapValues;
    }
    /**
     * @return For the single stat view, a list of boundaries for mapping different query values to colors. Must contain one element less than `sparkline_value_color_map_colors`.
     * 
     */
    public List<Double> sparklineValueColorMapValuesV2s() {
        return this.sparklineValueColorMapValuesV2s;
    }
    /**
     * @return For the single stat view, a list of display text values that different query values map to. Must contain one more element than `sparkline_value_text_map_thresholds`.
     * 
     */
    public List<String> sparklineValueTextMapTexts() {
        return this.sparklineValueTextMapTexts;
    }
    /**
     * @return For the single stat view, a list of threshold boundaries for mapping different query values to display text. Must contain one element less than `sparkline_value_text_map_text`.
     * 
     */
    public List<Double> sparklineValueTextMapThresholds() {
        return this.sparklineValueTextMapThresholds;
    }
    /**
     * @return Type of stacked chart (applicable only if chart type is `stacked`). `zero` (default) means stacked from y=0. `expand` means normalized from 0 to 1.  `wiggle` means minimize weighted changes. `silhouette` means to center the stream. Valid options are `zero`, `expand`, `wiggle`, `silhouette`, and `bars`.
     * 
     */
    public String stackType() {
        return this.stackType;
    }
    /**
     * @return For the tabular view, which mode to use to determine which point tags to display. Valid options are `all`, `top`, or `custom`.
     * 
     */
    public String tagMode() {
        return this.tagMode;
    }
    /**
     * @return For x-y scatterplots, whether to color more recent points as darker than older points.
     * 
     */
    public Boolean timeBasedColoring() {
        return this.timeBasedColoring;
    }
    /**
     * @return Chart Type. `line` refers to the Line Plot, `scatter` to the Point Plot, `stacked-area` to the Stacked Area plot, `table` to the Tabular View, `scatterplot-xy` to Scatter Plot, `markdown-widget` to the Markdown display, and `sparkline` to the Single Stat view. Valid options are`line`, `scatterplot`, `stacked-area`, `stacked-column`, `table`, `scatterplot-xy`, `markdown-widget`, `sparkline`, `globe`, `nodemap`, `top-k`, `status-list`, and `histogram`.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return Width, in minutes, of the time window to use for `last` windowing.
     * 
     */
    public Integer windowSize() {
        return this.windowSize;
    }
    /**
     * @return For the tabular view, whether to use the full time window for the query or the last X minutes. Valid options are `full` or `last`.
     * 
     */
    public String windowing() {
        return this.windowing;
    }
    /**
     * @return For x-y scatterplots, max value for the X-axis. Set to null for auto.
     * 
     */
    public Double xmax() {
        return this.xmax;
    }
    /**
     * @return For x-y scatterplots, min value for the X-axis. Set to null for auto.
     * 
     */
    public Double xmin() {
        return this.xmin;
    }
    public Boolean y0ScaleSiBy1024() {
        return this.y0ScaleSiBy1024;
    }
    /**
     * @return (Optional) Whether to automatically adjust magnitude labels and units for the left Y-axis to favor smaller magnitudes and larger units.
     * 
     */
    public Boolean y0UnitAutoscaling() {
        return this.y0UnitAutoscaling;
    }
    public Double y1Max() {
        return this.y1Max;
    }
    public Double y1Min() {
        return this.y1Min;
    }
    public Boolean y1ScaleSiBy1024() {
        return this.y1ScaleSiBy1024;
    }
    /**
     * @return (Optional) Whether to automatically adjust magnitude labels and units for the right Y-axis to favor smaller magnitudes and larger units.
     * 
     */
    public Boolean y1UnitAutoscaling() {
        return this.y1UnitAutoscaling;
    }
    /**
     * @return For plots with multiple Y-axes, units for right side Y-axis.
     * 
     */
    public String y1Units() {
        return this.y1Units;
    }
    /**
     * @return For x-y scatterplots, max value for the Y-axis. Set to null for auto.
     * 
     */
    public Double ymax() {
        return this.ymax;
    }
    /**
     * @return For x-y scatterplots, min value for the Y-axis. Set to null for auto.
     * 
     */
    public Double ymin() {
        return this.ymin;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDashboardsDashboardSectionRowChartChartSetting defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean autoColumnTags;
        private String columnTags;
        private List<String> customTags;
        private Integer expectedDataSpacing;
        private List<String> fixedLegendDisplayStats;
        private Boolean fixedLegendEnabled;
        private String fixedLegendFilterField;
        private Integer fixedLegendFilterLimit;
        private String fixedLegendFilterSort;
        private Boolean fixedLegendHideLabel;
        private String fixedLegendPosition;
        private Boolean fixedLegendUseRawStats;
        private Boolean groupBySource;
        private Boolean invertDynamicLegendHoverControl;
        private String lineType;
        private Double max;
        private Double min;
        private Integer numTags;
        private String plainMarkdownContent;
        private Boolean showHosts;
        private Boolean showLabels;
        private Boolean showRawValues;
        private Boolean sortValuesDescending;
        private Integer sparklineDecimalPrecision;
        private String sparklineDisplayColor;
        private String sparklineDisplayFontSize;
        private String sparklineDisplayHorizontalPosition;
        private String sparklineDisplayPostfix;
        private String sparklineDisplayPrefix;
        private String sparklineDisplayValueType;
        private String sparklineDisplayVerticalPosition;
        private String sparklineFillColor;
        private String sparklineLineColor;
        private String sparklineSize;
        private String sparklineValueColorMapApplyTo;
        private List<String> sparklineValueColorMapColors;
        private List<Integer> sparklineValueColorMapValues;
        private List<Double> sparklineValueColorMapValuesV2s;
        private List<String> sparklineValueTextMapTexts;
        private List<Double> sparklineValueTextMapThresholds;
        private String stackType;
        private String tagMode;
        private Boolean timeBasedColoring;
        private String type;
        private Integer windowSize;
        private String windowing;
        private Double xmax;
        private Double xmin;
        private Boolean y0ScaleSiBy1024;
        private Boolean y0UnitAutoscaling;
        private Double y1Max;
        private Double y1Min;
        private Boolean y1ScaleSiBy1024;
        private Boolean y1UnitAutoscaling;
        private String y1Units;
        private Double ymax;
        private Double ymin;
        public Builder() {}
        public Builder(GetDashboardsDashboardSectionRowChartChartSetting defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoColumnTags = defaults.autoColumnTags;
    	      this.columnTags = defaults.columnTags;
    	      this.customTags = defaults.customTags;
    	      this.expectedDataSpacing = defaults.expectedDataSpacing;
    	      this.fixedLegendDisplayStats = defaults.fixedLegendDisplayStats;
    	      this.fixedLegendEnabled = defaults.fixedLegendEnabled;
    	      this.fixedLegendFilterField = defaults.fixedLegendFilterField;
    	      this.fixedLegendFilterLimit = defaults.fixedLegendFilterLimit;
    	      this.fixedLegendFilterSort = defaults.fixedLegendFilterSort;
    	      this.fixedLegendHideLabel = defaults.fixedLegendHideLabel;
    	      this.fixedLegendPosition = defaults.fixedLegendPosition;
    	      this.fixedLegendUseRawStats = defaults.fixedLegendUseRawStats;
    	      this.groupBySource = defaults.groupBySource;
    	      this.invertDynamicLegendHoverControl = defaults.invertDynamicLegendHoverControl;
    	      this.lineType = defaults.lineType;
    	      this.max = defaults.max;
    	      this.min = defaults.min;
    	      this.numTags = defaults.numTags;
    	      this.plainMarkdownContent = defaults.plainMarkdownContent;
    	      this.showHosts = defaults.showHosts;
    	      this.showLabels = defaults.showLabels;
    	      this.showRawValues = defaults.showRawValues;
    	      this.sortValuesDescending = defaults.sortValuesDescending;
    	      this.sparklineDecimalPrecision = defaults.sparklineDecimalPrecision;
    	      this.sparklineDisplayColor = defaults.sparklineDisplayColor;
    	      this.sparklineDisplayFontSize = defaults.sparklineDisplayFontSize;
    	      this.sparklineDisplayHorizontalPosition = defaults.sparklineDisplayHorizontalPosition;
    	      this.sparklineDisplayPostfix = defaults.sparklineDisplayPostfix;
    	      this.sparklineDisplayPrefix = defaults.sparklineDisplayPrefix;
    	      this.sparklineDisplayValueType = defaults.sparklineDisplayValueType;
    	      this.sparklineDisplayVerticalPosition = defaults.sparklineDisplayVerticalPosition;
    	      this.sparklineFillColor = defaults.sparklineFillColor;
    	      this.sparklineLineColor = defaults.sparklineLineColor;
    	      this.sparklineSize = defaults.sparklineSize;
    	      this.sparklineValueColorMapApplyTo = defaults.sparklineValueColorMapApplyTo;
    	      this.sparklineValueColorMapColors = defaults.sparklineValueColorMapColors;
    	      this.sparklineValueColorMapValues = defaults.sparklineValueColorMapValues;
    	      this.sparklineValueColorMapValuesV2s = defaults.sparklineValueColorMapValuesV2s;
    	      this.sparklineValueTextMapTexts = defaults.sparklineValueTextMapTexts;
    	      this.sparklineValueTextMapThresholds = defaults.sparklineValueTextMapThresholds;
    	      this.stackType = defaults.stackType;
    	      this.tagMode = defaults.tagMode;
    	      this.timeBasedColoring = defaults.timeBasedColoring;
    	      this.type = defaults.type;
    	      this.windowSize = defaults.windowSize;
    	      this.windowing = defaults.windowing;
    	      this.xmax = defaults.xmax;
    	      this.xmin = defaults.xmin;
    	      this.y0ScaleSiBy1024 = defaults.y0ScaleSiBy1024;
    	      this.y0UnitAutoscaling = defaults.y0UnitAutoscaling;
    	      this.y1Max = defaults.y1Max;
    	      this.y1Min = defaults.y1Min;
    	      this.y1ScaleSiBy1024 = defaults.y1ScaleSiBy1024;
    	      this.y1UnitAutoscaling = defaults.y1UnitAutoscaling;
    	      this.y1Units = defaults.y1Units;
    	      this.ymax = defaults.ymax;
    	      this.ymin = defaults.ymin;
        }

        @CustomType.Setter
        public Builder autoColumnTags(Boolean autoColumnTags) {
            this.autoColumnTags = Objects.requireNonNull(autoColumnTags);
            return this;
        }
        @CustomType.Setter
        public Builder columnTags(String columnTags) {
            this.columnTags = Objects.requireNonNull(columnTags);
            return this;
        }
        @CustomType.Setter
        public Builder customTags(List<String> customTags) {
            this.customTags = Objects.requireNonNull(customTags);
            return this;
        }
        public Builder customTags(String... customTags) {
            return customTags(List.of(customTags));
        }
        @CustomType.Setter
        public Builder expectedDataSpacing(Integer expectedDataSpacing) {
            this.expectedDataSpacing = Objects.requireNonNull(expectedDataSpacing);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendDisplayStats(List<String> fixedLegendDisplayStats) {
            this.fixedLegendDisplayStats = Objects.requireNonNull(fixedLegendDisplayStats);
            return this;
        }
        public Builder fixedLegendDisplayStats(String... fixedLegendDisplayStats) {
            return fixedLegendDisplayStats(List.of(fixedLegendDisplayStats));
        }
        @CustomType.Setter
        public Builder fixedLegendEnabled(Boolean fixedLegendEnabled) {
            this.fixedLegendEnabled = Objects.requireNonNull(fixedLegendEnabled);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendFilterField(String fixedLegendFilterField) {
            this.fixedLegendFilterField = Objects.requireNonNull(fixedLegendFilterField);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendFilterLimit(Integer fixedLegendFilterLimit) {
            this.fixedLegendFilterLimit = Objects.requireNonNull(fixedLegendFilterLimit);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendFilterSort(String fixedLegendFilterSort) {
            this.fixedLegendFilterSort = Objects.requireNonNull(fixedLegendFilterSort);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendHideLabel(Boolean fixedLegendHideLabel) {
            this.fixedLegendHideLabel = Objects.requireNonNull(fixedLegendHideLabel);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendPosition(String fixedLegendPosition) {
            this.fixedLegendPosition = Objects.requireNonNull(fixedLegendPosition);
            return this;
        }
        @CustomType.Setter
        public Builder fixedLegendUseRawStats(Boolean fixedLegendUseRawStats) {
            this.fixedLegendUseRawStats = Objects.requireNonNull(fixedLegendUseRawStats);
            return this;
        }
        @CustomType.Setter
        public Builder groupBySource(Boolean groupBySource) {
            this.groupBySource = Objects.requireNonNull(groupBySource);
            return this;
        }
        @CustomType.Setter
        public Builder invertDynamicLegendHoverControl(Boolean invertDynamicLegendHoverControl) {
            this.invertDynamicLegendHoverControl = Objects.requireNonNull(invertDynamicLegendHoverControl);
            return this;
        }
        @CustomType.Setter
        public Builder lineType(String lineType) {
            this.lineType = Objects.requireNonNull(lineType);
            return this;
        }
        @CustomType.Setter
        public Builder max(Double max) {
            this.max = Objects.requireNonNull(max);
            return this;
        }
        @CustomType.Setter
        public Builder min(Double min) {
            this.min = Objects.requireNonNull(min);
            return this;
        }
        @CustomType.Setter
        public Builder numTags(Integer numTags) {
            this.numTags = Objects.requireNonNull(numTags);
            return this;
        }
        @CustomType.Setter
        public Builder plainMarkdownContent(String plainMarkdownContent) {
            this.plainMarkdownContent = Objects.requireNonNull(plainMarkdownContent);
            return this;
        }
        @CustomType.Setter
        public Builder showHosts(Boolean showHosts) {
            this.showHosts = Objects.requireNonNull(showHosts);
            return this;
        }
        @CustomType.Setter
        public Builder showLabels(Boolean showLabels) {
            this.showLabels = Objects.requireNonNull(showLabels);
            return this;
        }
        @CustomType.Setter
        public Builder showRawValues(Boolean showRawValues) {
            this.showRawValues = Objects.requireNonNull(showRawValues);
            return this;
        }
        @CustomType.Setter
        public Builder sortValuesDescending(Boolean sortValuesDescending) {
            this.sortValuesDescending = Objects.requireNonNull(sortValuesDescending);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDecimalPrecision(Integer sparklineDecimalPrecision) {
            this.sparklineDecimalPrecision = Objects.requireNonNull(sparklineDecimalPrecision);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayColor(String sparklineDisplayColor) {
            this.sparklineDisplayColor = Objects.requireNonNull(sparklineDisplayColor);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayFontSize(String sparklineDisplayFontSize) {
            this.sparklineDisplayFontSize = Objects.requireNonNull(sparklineDisplayFontSize);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayHorizontalPosition(String sparklineDisplayHorizontalPosition) {
            this.sparklineDisplayHorizontalPosition = Objects.requireNonNull(sparklineDisplayHorizontalPosition);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayPostfix(String sparklineDisplayPostfix) {
            this.sparklineDisplayPostfix = Objects.requireNonNull(sparklineDisplayPostfix);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayPrefix(String sparklineDisplayPrefix) {
            this.sparklineDisplayPrefix = Objects.requireNonNull(sparklineDisplayPrefix);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayValueType(String sparklineDisplayValueType) {
            this.sparklineDisplayValueType = Objects.requireNonNull(sparklineDisplayValueType);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineDisplayVerticalPosition(String sparklineDisplayVerticalPosition) {
            this.sparklineDisplayVerticalPosition = Objects.requireNonNull(sparklineDisplayVerticalPosition);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineFillColor(String sparklineFillColor) {
            this.sparklineFillColor = Objects.requireNonNull(sparklineFillColor);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineLineColor(String sparklineLineColor) {
            this.sparklineLineColor = Objects.requireNonNull(sparklineLineColor);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineSize(String sparklineSize) {
            this.sparklineSize = Objects.requireNonNull(sparklineSize);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineValueColorMapApplyTo(String sparklineValueColorMapApplyTo) {
            this.sparklineValueColorMapApplyTo = Objects.requireNonNull(sparklineValueColorMapApplyTo);
            return this;
        }
        @CustomType.Setter
        public Builder sparklineValueColorMapColors(List<String> sparklineValueColorMapColors) {
            this.sparklineValueColorMapColors = Objects.requireNonNull(sparklineValueColorMapColors);
            return this;
        }
        public Builder sparklineValueColorMapColors(String... sparklineValueColorMapColors) {
            return sparklineValueColorMapColors(List.of(sparklineValueColorMapColors));
        }
        @CustomType.Setter
        public Builder sparklineValueColorMapValues(List<Integer> sparklineValueColorMapValues) {
            this.sparklineValueColorMapValues = Objects.requireNonNull(sparklineValueColorMapValues);
            return this;
        }
        public Builder sparklineValueColorMapValues(Integer... sparklineValueColorMapValues) {
            return sparklineValueColorMapValues(List.of(sparklineValueColorMapValues));
        }
        @CustomType.Setter
        public Builder sparklineValueColorMapValuesV2s(List<Double> sparklineValueColorMapValuesV2s) {
            this.sparklineValueColorMapValuesV2s = Objects.requireNonNull(sparklineValueColorMapValuesV2s);
            return this;
        }
        public Builder sparklineValueColorMapValuesV2s(Double... sparklineValueColorMapValuesV2s) {
            return sparklineValueColorMapValuesV2s(List.of(sparklineValueColorMapValuesV2s));
        }
        @CustomType.Setter
        public Builder sparklineValueTextMapTexts(List<String> sparklineValueTextMapTexts) {
            this.sparklineValueTextMapTexts = Objects.requireNonNull(sparklineValueTextMapTexts);
            return this;
        }
        public Builder sparklineValueTextMapTexts(String... sparklineValueTextMapTexts) {
            return sparklineValueTextMapTexts(List.of(sparklineValueTextMapTexts));
        }
        @CustomType.Setter
        public Builder sparklineValueTextMapThresholds(List<Double> sparklineValueTextMapThresholds) {
            this.sparklineValueTextMapThresholds = Objects.requireNonNull(sparklineValueTextMapThresholds);
            return this;
        }
        public Builder sparklineValueTextMapThresholds(Double... sparklineValueTextMapThresholds) {
            return sparklineValueTextMapThresholds(List.of(sparklineValueTextMapThresholds));
        }
        @CustomType.Setter
        public Builder stackType(String stackType) {
            this.stackType = Objects.requireNonNull(stackType);
            return this;
        }
        @CustomType.Setter
        public Builder tagMode(String tagMode) {
            this.tagMode = Objects.requireNonNull(tagMode);
            return this;
        }
        @CustomType.Setter
        public Builder timeBasedColoring(Boolean timeBasedColoring) {
            this.timeBasedColoring = Objects.requireNonNull(timeBasedColoring);
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        @CustomType.Setter
        public Builder windowSize(Integer windowSize) {
            this.windowSize = Objects.requireNonNull(windowSize);
            return this;
        }
        @CustomType.Setter
        public Builder windowing(String windowing) {
            this.windowing = Objects.requireNonNull(windowing);
            return this;
        }
        @CustomType.Setter
        public Builder xmax(Double xmax) {
            this.xmax = Objects.requireNonNull(xmax);
            return this;
        }
        @CustomType.Setter
        public Builder xmin(Double xmin) {
            this.xmin = Objects.requireNonNull(xmin);
            return this;
        }
        @CustomType.Setter
        public Builder y0ScaleSiBy1024(Boolean y0ScaleSiBy1024) {
            this.y0ScaleSiBy1024 = Objects.requireNonNull(y0ScaleSiBy1024);
            return this;
        }
        @CustomType.Setter
        public Builder y0UnitAutoscaling(Boolean y0UnitAutoscaling) {
            this.y0UnitAutoscaling = Objects.requireNonNull(y0UnitAutoscaling);
            return this;
        }
        @CustomType.Setter
        public Builder y1Max(Double y1Max) {
            this.y1Max = Objects.requireNonNull(y1Max);
            return this;
        }
        @CustomType.Setter
        public Builder y1Min(Double y1Min) {
            this.y1Min = Objects.requireNonNull(y1Min);
            return this;
        }
        @CustomType.Setter
        public Builder y1ScaleSiBy1024(Boolean y1ScaleSiBy1024) {
            this.y1ScaleSiBy1024 = Objects.requireNonNull(y1ScaleSiBy1024);
            return this;
        }
        @CustomType.Setter
        public Builder y1UnitAutoscaling(Boolean y1UnitAutoscaling) {
            this.y1UnitAutoscaling = Objects.requireNonNull(y1UnitAutoscaling);
            return this;
        }
        @CustomType.Setter
        public Builder y1Units(String y1Units) {
            this.y1Units = Objects.requireNonNull(y1Units);
            return this;
        }
        @CustomType.Setter
        public Builder ymax(Double ymax) {
            this.ymax = Objects.requireNonNull(ymax);
            return this;
        }
        @CustomType.Setter
        public Builder ymin(Double ymin) {
            this.ymin = Objects.requireNonNull(ymin);
            return this;
        }
        public GetDashboardsDashboardSectionRowChartChartSetting build() {
            final var o = new GetDashboardsDashboardSectionRowChartChartSetting();
            o.autoColumnTags = autoColumnTags;
            o.columnTags = columnTags;
            o.customTags = customTags;
            o.expectedDataSpacing = expectedDataSpacing;
            o.fixedLegendDisplayStats = fixedLegendDisplayStats;
            o.fixedLegendEnabled = fixedLegendEnabled;
            o.fixedLegendFilterField = fixedLegendFilterField;
            o.fixedLegendFilterLimit = fixedLegendFilterLimit;
            o.fixedLegendFilterSort = fixedLegendFilterSort;
            o.fixedLegendHideLabel = fixedLegendHideLabel;
            o.fixedLegendPosition = fixedLegendPosition;
            o.fixedLegendUseRawStats = fixedLegendUseRawStats;
            o.groupBySource = groupBySource;
            o.invertDynamicLegendHoverControl = invertDynamicLegendHoverControl;
            o.lineType = lineType;
            o.max = max;
            o.min = min;
            o.numTags = numTags;
            o.plainMarkdownContent = plainMarkdownContent;
            o.showHosts = showHosts;
            o.showLabels = showLabels;
            o.showRawValues = showRawValues;
            o.sortValuesDescending = sortValuesDescending;
            o.sparklineDecimalPrecision = sparklineDecimalPrecision;
            o.sparklineDisplayColor = sparklineDisplayColor;
            o.sparklineDisplayFontSize = sparklineDisplayFontSize;
            o.sparklineDisplayHorizontalPosition = sparklineDisplayHorizontalPosition;
            o.sparklineDisplayPostfix = sparklineDisplayPostfix;
            o.sparklineDisplayPrefix = sparklineDisplayPrefix;
            o.sparklineDisplayValueType = sparklineDisplayValueType;
            o.sparklineDisplayVerticalPosition = sparklineDisplayVerticalPosition;
            o.sparklineFillColor = sparklineFillColor;
            o.sparklineLineColor = sparklineLineColor;
            o.sparklineSize = sparklineSize;
            o.sparklineValueColorMapApplyTo = sparklineValueColorMapApplyTo;
            o.sparklineValueColorMapColors = sparklineValueColorMapColors;
            o.sparklineValueColorMapValues = sparklineValueColorMapValues;
            o.sparklineValueColorMapValuesV2s = sparklineValueColorMapValuesV2s;
            o.sparklineValueTextMapTexts = sparklineValueTextMapTexts;
            o.sparklineValueTextMapThresholds = sparklineValueTextMapThresholds;
            o.stackType = stackType;
            o.tagMode = tagMode;
            o.timeBasedColoring = timeBasedColoring;
            o.type = type;
            o.windowSize = windowSize;
            o.windowing = windowing;
            o.xmax = xmax;
            o.xmin = xmin;
            o.y0ScaleSiBy1024 = y0ScaleSiBy1024;
            o.y0UnitAutoscaling = y0UnitAutoscaling;
            o.y1Max = y1Max;
            o.y1Min = y1Min;
            o.y1ScaleSiBy1024 = y1ScaleSiBy1024;
            o.y1UnitAutoscaling = y1UnitAutoscaling;
            o.y1Units = y1Units;
            o.ymax = ymax;
            o.ymin = ymin;
            return o;
        }
    }
}
